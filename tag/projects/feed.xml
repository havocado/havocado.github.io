<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/tag/projects/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2020-06-16T00:46:47+09:00</updated>
  <id>http://localhost:4000/tag/projects/feed.xml</id>

  
  
  

  
    <title type="html">Hailey’s Programming Blog | </title>
  

  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Sapiens</title>
      <link href="http://localhost:4000/sapiens" rel="alternate" type="text/html" title="Sapiens" />
      <published>2020-05-02T21:56:00+09:00</published>
      <updated>2020-05-02T21:56:00+09:00</updated>
      <id>http://localhost:4000/sapiens</id>
      <content type="html" xml:base="http://localhost:4000/sapiens">&lt;p&gt;*This page is still being prepared!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Hailey Ahn</name>
        
        
      </author>

      

      
        <category term="projects" />
      

      
        <summary type="html">*This page is still being prepared!</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Special Fortification Unit</title>
      <link href="http://localhost:4000/special-fortification-unit-proposal" rel="alternate" type="text/html" title="Special Fortification Unit" />
      <published>2020-04-23T17:00:00+09:00</published>
      <updated>2020-04-23T17:00:00+09:00</updated>
      <id>http://localhost:4000/special-fortification-unit-proposal</id>
      <content type="html" xml:base="http://localhost:4000/special-fortification-unit-proposal">&lt;p&gt;*This page is still being prepared!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Hailey Ahn</name>
        
        
      </author>

      

      
        <category term="projects" />
      

      
        <summary type="html">*This page is still being prepared!</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">ColorQuirrel</title>
      <link href="http://localhost:4000/ColorQuirrel" rel="alternate" type="text/html" title="ColorQuirrel" />
      <published>2020-04-23T17:00:00+09:00</published>
      <updated>2020-04-23T17:00:00+09:00</updated>
      <id>http://localhost:4000/ColorQuirrel</id>
      <content type="html" xml:base="http://localhost:4000/ColorQuirrel">&lt;p style=&quot;display:none&quot;&gt;Project: A MATLAB program for image processing&lt;/p&gt;

&lt;h1&gt;ColorQuirrel&lt;/h1&gt;
&lt;br&gt;

&lt;h3&gt;Motivation&lt;/h3&gt;
&lt;br&gt;
&lt;p&gt;&lt;strong&gt;ColorQuirrel&lt;/strong&gt; is my individual final project for SFU CMPT 365: Multimedia Systems for Fall 2019. It was planned to be [1] Course-related, [2] Available for incremental development, [3] Easy to check middle results, and [4] Contain enough depth as a final project for 300-level course.&lt;/p&gt;
&lt;p&gt;ColorQuirrel is a MATLAB based program that plays around color spaces. It converts the image to several different ways to represent the data, extracts the representative color from the image by clustering the data, and uses down-sampling method to speed up the procedure.&lt;/p&gt;
&lt;p&gt;Below is the description for my project.&lt;/p&gt;

&lt;h3&gt;Code&lt;/h3&gt;
&lt;br&gt;
&lt;p&gt;You can find the code &lt;a href=&quot;colorquirrel-code&quot;&gt;here.&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Instructions on running the program (General):&lt;/h3&gt;
&lt;img style=&quot;width:70%&quot; src=&quot;assets/images/z-colorquirrel-1.png&quot; alt=&quot;colorquirrel HSV conversion screenshot&quot;&gt;
&lt;ol&gt;
    &lt;li&gt;Run Colorquirrel.m on MATLAB (version at least R2018).&lt;/li&gt;
    &lt;li&gt;When “Enter image path:” shows, enter the source path of the image with quotation marks ‘ ’ appended. (If quotation marks are not included, the program returns an error.)&lt;/li&gt;
    &lt;li&gt;Select the mode. (If it doesn’t do anything, select any other mode and select again.) 4) If there are options available, choose the desired option. Otherwise, select ‘Go’.&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;1.	Basic implementation of color space conversions.&lt;/h3&gt;
&lt;br&gt;
&lt;h4&gt;1.1.	RGB    [Replication of existing idea]&lt;/h4&gt;
&lt;br&gt;
&lt;p&gt;RGB color space is how the pictures are shown on monitors. In this feature, I focused on implementing the very basic feature to the GUI. The idea was very simple, but I spent most of the time on trial-and-errors, involving languages, understanding the GUI, and dealing with MATLAB data types, uint8 and double.&lt;/p&gt;
&lt;p&gt;The program starts from reading the file. This step is done by MATLAB’s built-in imread function.&lt;/p&gt;
&lt;img style=&quot;width:70%&quot; src=&quot;assets/images/z-colorquirrel-rgb.png&quot; alt=&quot;colorquirrel RGB conversion screenshot&quot;&gt;
&lt;p&gt;For dividing the RGB images, I used the way MATLAB deals with pixel images. I made 3 new matrices, each for R, G, and B, each taking only the needed entries from the original image. Then I showed the image using the built-in imshow function.&lt;/p&gt;


&lt;h4&gt;1.2.	CMY    [Replication of existing idea]&lt;/h4&gt;
&lt;br&gt;
&lt;p&gt;CMY color space is the subtractive color space. It is also how pictures are shown on printed papers – it is actually CMYK, but CMYK is made after CMY.&lt;/p&gt;
&lt;img style=&quot;width:70%&quot; src=&quot;assets/images/z-colorquirrel-cmy.png&quot; alt=&quot;colorquirrel CMY conversion screenshot&quot;&gt;
&lt;p&gt;The procedure is as follows:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Convert RGB to CMY. There exists a built-in function in MATLAB, but I wrote my own for project purpose. The formula was easy to obtain:&lt;/li&gt;
    &lt;img style=&quot;width:30%&quot; src=&quot;assets/images/z-colorquirrel-cmy-formula.png&quot; alt=&quot;colorquirrel CMY conversion formula&quot;&gt;
    &lt;li&gt;Generate 3 new matrices to contain each C, M, and Y, as done in 1.1.RGB.&lt;/li&gt;
    &lt;li&gt;Convert each matrices to RGB color space. The inverse formula was obvious. There is also a built-in function in MATLAB, but I wrote my own for project purpose again.&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;1.3.	CMYK    [Replication of existing idea]&lt;/h4&gt;
&lt;br&gt;
&lt;p&gt;CMYK color space is an economic form of CMY color space. It is made because black ink is usually cheaper than other colors.&lt;/p&gt;
&lt;img style=&quot;width:70%&quot; src=&quot;assets/images/z-colorquirrel-cmyk.png&quot; alt=&quot;colorquirrel CMYK conversion screenshot&quot;&gt;
&lt;p&gt;The procedure is as follows:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Perform a CMY color space conversion, as done in 1.2. CMY.&lt;/li&gt;
    &lt;li&gt;Make a new matrix, with a fourth entry on each pixel. The fourth entry contains the minimum value among R, G, B of that specific pixel. Subtract the fourth entry from all other colors. This way, the smallest entry becomes 0.&lt;/li&gt;
    &lt;li&gt;For displaying on the GUI, I processed the C, M, Y components as before. More specifically, the values for R, G, B are set to 255-(original), and non-used components are all set to 255. For K component, I made a new RGB matrix, and set all R/G/B values as 1/3 of the K value.&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;1.4.	HSV    [Replication of existing idea]&lt;/h4&gt;
&lt;br&gt;
&lt;p&gt;HSV color space is less obvious than CMY or CMYK. Some of the formulas I got from google didn’t consider the range of entries (sometimes R/G/B was mapped on [0, 1]; other times they were [0, 255].), so I had a few trials and errors on this part.&lt;/p&gt;
&lt;img style=&quot;width:70%&quot; src=&quot;assets/images/z-colorquirrel-error.png&quot; alt=&quot;colorquirrel error screenshot&quot;&gt;
&lt;p&gt;(*This is one of the ‘wrong’ results the program produced while running. It is very non-obvious to check.)&lt;/p&gt;
&lt;img style=&quot;width:70%&quot; src=&quot;assets/images/z-colorquirrel-hsv.png&quot; alt=&quot;colorquirrel HSV conversion screenshot&quot;&gt;
&lt;p&gt;The procedure was as follows:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Convert RGB to HSV. I wrote my own function for it. I obtained the formula from:
    https://www.rapidtables.com/convert/color/rgb-to-hsv.html&lt;/li&gt;
    &lt;li&gt;Since HSV entries per pixel are dependent to each other, they cannot be divided into three different images. In fact, dividing Hue-Saturation-Value of the image doesn’t really make sense. So I used the trick:&lt;/li&gt;
    &lt;li&gt;For Hue, I made a new matrix with same hue, but all Saturation set to 0.5 and all Values set to 1. (Saturation 0 or 1 will be black/white image with no useful information, and high Value makes colors more intense.) Then I ran the HSV to RGB (own function) to that image: formula obtained from https://cs.stackexchange.com/questions/64549/convert-hsv-to-rgbcolors&lt;/li&gt;
    &lt;li&gt;For Saturation and Value, I multiplied 255 and rounded the number, since the original is a floating point number in [0, 1] and I wanted a grayscale image. Then I saved the data to the fourth entry of CMYK image, with all other entries set to 0. Lastly I converted CMYK-&gt;CMY-&gt;RGB, and obtained the display-able image.&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;2.	Color extractor&lt;/h3&gt;
&lt;br&gt;
&lt;p&gt;Color extraction from a photo is commonly used by artists, who needs inspiration for colors and moods. The idea is simple: Get a ‘representative’ color from a photo.&lt;/p&gt;

&lt;h4&gt;2.1.	Trials and errors&lt;/h4&gt;
&lt;br&gt;
&lt;p&gt;For the most straightforward method, I decided to make a 256*256*256 ‘container’ that stores frequencies of colors, and extract the most frequent values of the container; which is also the most frequent colors of the image.&lt;/p&gt;
&lt;p&gt;This turned out to be not the feature intended. Usually the colors were in a very narrow range, almost non distinguishable, for obvious reasons.&lt;/p&gt;


&lt;h4&gt;2.2.	Colorpicker (k-means clustering)&lt;br&gt;[Replication of existing idea]  [Original solution]&lt;/h4&gt;
&lt;br&gt;
&lt;p&gt;The alternative method is k-means clustering. MATLAB built-in program imsegkmeans was used for clustering the colors. The program reads the color data, and clusters the data to the chosen number of clusters.&lt;/p&gt;
&lt;img style=&quot;width:70%&quot; src=&quot;assets/images/z-colorquirrel-picker.png&quot; alt=&quot;colorquirrel colorpicker screenshot&quot;&gt;
&lt;p&gt;This turned out very well, with expected results. The scatterplot on the left is the distribution of colors. Red circles are where the selected colors are located.&lt;/p&gt;
&lt;p&gt;Procedure was as follows:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Obtain the ‘mean’s of cluster by MATLAB function. The output data is returned as a k*3 matrix, each row containing R, G, B values of representative colors.&lt;/li&gt;
    &lt;li&gt;To display the ‘palette’, generate a 1*k*3 matrix, which is the size of the palette image. Assign each values of the color entries to the palette.&lt;/li&gt;
    &lt;li&gt;The scatterplot, showing the distribution of colors and the location of palette images, is drawn using the idea from 2.1. Trial and errors; all the image elements are saved into the containers, and scatterplot is drawn on 256*256*256, each representing R, G, B parameters.&lt;/li&gt;
    &lt;li&gt;Red circles on the plot are the ‘representative’ colors shown on the palette. They are drawn after the whole scatterplot is drawn. This plot provides an intuitive way to understand how the colorpicker works.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;2.3.	Downsampling   [Original solution]&lt;/h4&gt;
&lt;br&gt;
&lt;p&gt;The above method doesn’t take a short time, since it has to work with big image data; the image size used for testing was around 1500*2000. The program has to cluster all the data, get the means of the cluster, plot all of them on the plot…..which is very ineffective for obtaining a few colors.&lt;/p&gt;
&lt;p&gt;Downsampling is inspired by JPEG’s downsampling for scaling quality. Colors in image are usually similar to the color next to it, so some loss of pixels wouldn’t matter. Furthermore, people are not very sensitive to colors being slightly incorrect.&lt;/p&gt;
&lt;p&gt;Procedure was as follows:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Create a new matrix, with desired size after downsampling.&lt;/li&gt;
    &lt;li&gt;Go over the data, skipping the entries depending on the downsampling parameter. This is O(height*width), but still much better compared to the running time of data clustering.&lt;/li&gt;
    &lt;li&gt;Use the downsampled image to 2.2. Colorpicker.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The result is almost non-distinguishable from the original version. However, the significant decrease of points displayed on the plot shows that the idea is successfully implemented.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Hailey Ahn</name>
        
        
      </author>

      

      
        <category term="projects" />
      

      
        <summary type="html">Project: A MATLAB program for image processing</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Strogatz Love Affairs Model</title>
      <link href="http://localhost:4000/Strogatz" rel="alternate" type="text/html" title="Strogatz Love Affairs Model" />
      <published>2020-06-06T00:58:00+09:00</published>
      <updated>2020-06-06T00:58:00+09:00</updated>
      <id>http://localhost:4000/Strogatz</id>
      <content type="html" xml:base="http://localhost:4000/Strogatz">&lt;h2&gt;Strogatz Love Affairs Model&lt;/h2&gt;
&lt;hr&gt;
&lt;canvas id=&quot;strogatz-canvas&quot; width=&quot;50%&quot; height=&quot;30%&quot;&gt;&lt;/canvas&gt;
&lt;br&gt;

&lt;div class=&quot;slidecontainer&quot; style=&quot;width:100%;float:left;text-align:left&quot;&gt;
  &lt;p id=&quot;a_r-message&quot;&gt;Modify &lt;var&gt;a&lt;sub&gt;r&lt;/sub&gt;&lt;/var&gt;&lt;/p&gt;
  &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;4000&quot; value=&quot;2000&quot; class=&quot;slider&quot; id=&quot;a_r-slider&quot;&gt;

  &lt;p id=&quot;a_j-message&quot;&gt;Modify &lt;var&gt;a_j&lt;/var&gt;&lt;/p&gt;
  &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;4000&quot; value=&quot;2000&quot; class=&quot;slider&quot; id=&quot;a_j-slider&quot;&gt;

  &lt;p id=&quot;p_r-message&quot;&gt;Modify &lt;var&gt;p_r&lt;/var&gt;&lt;/p&gt;
  &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;4000&quot; value=&quot;2000&quot; class=&quot;slider&quot; id=&quot;p_r-slider&quot;&gt;

  &lt;p id=&quot;p_j-message&quot;&gt;Modify &lt;var&gt;p_j&lt;/var&gt;&lt;/p&gt;
  &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;4000&quot; value=&quot;2000&quot; class=&quot;slider&quot; id=&quot;p_j-slider&quot;&gt;

  &lt;button id=&quot;convert-log-scale&quot; type=&quot;button&quot;&gt;Draw in Log scale&lt;/button&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;ul&gt;
  &lt;li&gt;The graph is plotted via Chart.js.&lt;/li&gt;
  &lt;li&gt;Explanations for this will be updated later when I'm not busy.&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/0.5.7/chartjs-plugin-annotation.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  let strogatz_canvas = document.getElementById(&quot;strogatz-canvas&quot;);
  let strogatz_ctx = strogatz_canvas.getContext(&quot;2d&quot;);
  let strogatz_chart = new Chart(strogatz_ctx, {
    type: 'line',
    animation: false,
    data: {
      datasets: [],
    },
    options: {
      annotation: {
        drawTime: 'afterDatasetsDraw',
        annotations: []
      }
    }
  });

  // Constants (Parameters)
  let a_r = 1;
  let a_j = 1;
  let p_r = 0.2;
  let p_j = -0.2;

  // Romeo and Juliet in (t = 0)
  let r_0 = 1;
  let j_0 = 1;

  // Parameters for plotting
  let t_start = 0;
  let t_max = 100;
  let plot_handle;
  let update_interval = 0;
  let log_scale = false;

  // Setting up t-axis for time
  let t = [];
  let t_label = [];
  for (let i = t_start; i &lt;= t_max; i++) {
    t.push(i);
    t_label.push(i);
  }
  strogatz_chart.data.labels = t_label;

  // Settings for Romeo
  let romeo_data = [];
  let romeo = {
    label: 'Romeo',
    fill: false,
    pointRadius: 0,
    borderColor: &quot;red&quot;,
    data: romeo_data
  };
  strogatz_chart.data.datasets.push(romeo);

  // Settings for Juliet
  let juliet_data = [];
  let juliet = {
    label: 'Juliet',
    fill: false,
    pointRadius: 0,
    borderColor: &quot;blue&quot;,
    data: juliet_data
  };
  strogatz_chart.data.datasets.push(juliet);

  // Plot Love;
  let plot_Love = function() {
    clearTimeout(plot_handle);

    strogatz_chart.data.datasets[0].data = []; // Romeo
    strogatz_chart.data.datasets[1].data = []; // Juliet

    if (log_scale) {
      strogatz_chart.data.datasets[0].data.push(Math.log10(r_0));
      strogatz_chart.data.datasets[1].data.push(Math.log10(j_0));
    }
    else {
      strogatz_chart.data.datasets[0].data.push(r_0);
      strogatz_chart.data.datasets[1].data.push(j_0);
    }

    let r_prev = r_0;
    let j_prev = j_0;

    let i = t_start;
    let run_process = function() {
      // Calculate current
      let r_current = a_r * r_prev + p_r * j_prev;
      let j_current = a_j * j_prev + p_j * r_prev;

      // Push calculated data
      if (log_scale) {
        if (r_current &gt; 0) {
          strogatz_chart.data.datasets[0].data.push(Math.log10(r_current));
        }
        else if (r_current &lt; 0) {
          strogatz_chart.data.datasets[0].data.push(-Math.log10(Math.abs(r_current)));
        }
        if (j_current &gt; 0) {
          strogatz_chart.data.datasets[1].data.push(Math.log10(j_current));
        }
        else if (j_current &lt; 0) {
          strogatz_chart.data.datasets[1].data.push(-Math.log10(Math.abs(j_current)));
        }
      }
      else {
        strogatz_chart.data.datasets[0].data.push(r_current);
        strogatz_chart.data.datasets[1].data.push(j_current);
      }

      // Update prev
      r_prev = r_current;
      j_prev = j_current;

      strogatz_chart.update(); // Uncomment for updating each steps

      i++;
      if (i &gt; t_max) {
        strogatz_chart.update();
        return;
      }
      plot_handle = setTimeout(run_process, update_interval);
    };
    run_process();


    strogatz_chart.update(); // Uncomment (with above) for updating each steps
  };

  // Sliders
  let a_r_slider = document.getElementById(&quot;a_r-slider&quot;);
  a_r_slider.value = a_r*200 + 2000;
  let a_j_slider = document.getElementById(&quot;a_j-slider&quot;);
  a_j_slider.value = a_j*200 + 2000;
  let p_r_slider = document.getElementById(&quot;p_r-slider&quot;);
  p_r_slider.value = p_r*200 + 2000;
  let p_j_slider = document.getElementById(&quot;p_j-slider&quot;);
  p_j_slider.value = p_j*200 + 2000;
  let a_r_message = document.getElementById(&quot;a_r-message&quot;);
  a_r_message.innerHTML = &quot;Modify &lt;var&gt;a&lt;sub&gt;r&lt;/sub&gt;&lt;/var&gt; =  &quot; + a_r;
  let a_j_message = document.getElementById(&quot;a_j-message&quot;);
  a_j_message.innerHTML = &quot;Modify &lt;var&gt;a&lt;sub&gt;j&lt;/sub&gt;&lt;/var&gt; =  &quot; + a_j;
  let p_r_message = document.getElementById(&quot;p_r-message&quot;);
  p_r_message.innerHTML = &quot;Modify &lt;var&gt;p&lt;sub&gt;r&lt;/sub&gt;&lt;/var&gt; =  &quot; + p_r;
  let p_j_message = document.getElementById(&quot;p_j-message&quot;);
  p_j_message.innerHTML = &quot;Modify &lt;var&gt;p&lt;sub&gt;j&lt;/sub&gt;&lt;/var&gt; =  &quot; + p_j;
  let convert_scale_botton = document.getElementById(&quot;convert-log-scale&quot;);

  // Slider callbacks
  a_r_slider.oninput = function(){
    a_r = (this.value - 2000)/200;
    a_r_message.innerHTML = &quot;Modify &lt;var&gt;a&lt;sub&gt;r&lt;/sub&gt;&lt;/var&gt; =  &quot; + a_r;
    plot_Love();
  };
  a_j_slider.oninput = function(){
    a_j = (this.value - 2000)/200;
    a_j_message.innerHTML = &quot;Modify &lt;var&gt;a&lt;sub&gt;j&lt;/sub&gt;&lt;/var&gt; =  &quot; + a_j;
    plot_Love();
  };
  p_r_slider.oninput = function(){
    p_r = (this.value - 2000)/200;
    p_r_message.innerHTML = &quot;Modify &lt;var&gt;p&lt;sub&gt;r&lt;/sub&gt;&lt;/var&gt; =  &quot; + p_r;
    plot_Love();
  };
  p_j_slider.oninput = function(){
    p_j = (this.value - 2000)/200;
    p_j_message.innerHTML = &quot;Modify &lt;var&gt;p&lt;sub&gt;j&lt;/sub&gt;&lt;/var&gt; =  &quot; + p_j;
    plot_Love();
  };

  // Button callbacks
  convert_scale_botton.onclick = function() {
    if (log_scale) {
      convert_scale_botton.innerHTML = &quot;Draw in Log scale&quot;;
    }
    else {
      convert_scale_botton.innerHTML = &quot;Draw without Log scale&quot;;
    }
    log_scale = !log_scale;

    plot_Love();
  };

  // Initial graph plotted here
  strogatz_chart.update();
  plot_Love();


&lt;/script&gt;
&lt;style&gt;
  .slidecontainer {
    width: 100%; /* Width of the outside container */
  }

  /* The slider itself */
  .slider {
    -webkit-appearance: none;  /* Override default CSS styles */
    appearance: none;
    width: 100%; /* Full-width */
    height: 25px; /* Specified height */
    background: #d3d3d3; /* Grey background */
    outline: none; /* Remove outline */
    opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
    -webkit-transition: .2s; /* 0.2 seconds transition on hover */
    transition: opacity .2s;
  }

  /* Mouse-over effects */
  .slider:hover {
    opacity: 1; /* Fully shown on mouse-over */
  }

  /* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
  .slider::-webkit-slider-thumb {
    -webkit-appearance: none; /* Override default look */
    appearance: none;
    width: 25px; /* Set a specific slider handle width */
    height: 25px; /* Slider handle height */
    background: black; /* Green background */
    cursor: pointer; /* Cursor on hover */
  }

  .slider::-moz-range-thumb {
    width: 25px; /* Set a specific slider handle width */
    height: 25px; /* Slider handle height */
    background: black; /* Green background */
    cursor: pointer; /* Cursor on hover */
  }
&lt;/style&gt;</content>

      
      
      
      
      

      <author>
          <name>Hailey Ahn</name>
        
        
      </author>

      

      
        <category term="projects" />
      

      
        <summary type="html">Strogatz Love Affairs Model</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Cobwebbing Analysis for Discrete Logistic Model</title>
      <link href="http://localhost:4000/cobwebbing" rel="alternate" type="text/html" title="Cobwebbing Analysis for Discrete Logistic Model" />
      <published>2020-06-06T00:58:00+09:00</published>
      <updated>2020-06-06T00:58:00+09:00</updated>
      <id>http://localhost:4000/cobwebbing</id>
      <content type="html" xml:base="http://localhost:4000/cobwebbing">&lt;h2&gt;Cobwebbing Analysis for Discrete Logistic Model&lt;/h2&gt;
&lt;hr&gt;
&lt;canvas id=&quot;cobweb-canvas&quot; width=&quot;700&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;
&lt;br&gt;

&lt;div class=&quot;slidecontainer&quot; style=&quot;width:100%;float:left;text-align:left&quot;&gt;
  &lt;p&gt;Modify &lt;var&gt;r&lt;/var&gt;&lt;/p&gt;
  &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;4000&quot; value=&quot;3300&quot; class=&quot;slider&quot; id=&quot;r-slider&quot;&gt;

  &lt;p&gt;Modify Cobwebbing Update Time&lt;/p&gt;
  &lt;input type=&quot;range&quot; min=&quot;1&quot; max=&quot;4000&quot; value=&quot;200&quot; class=&quot;slider&quot; id=&quot;interval-slider&quot;&gt;

&lt;/div&gt;

&lt;hr&gt;
&lt;ul&gt;
  &lt;li&gt;The graph is plotted via Chart.js.&lt;/li&gt;
  &lt;li&gt;Explanations for this will be updated later when I'm not busy.&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/0.5.7/chartjs-plugin-annotation.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    let cobweb_canvas = document.getElementById(&quot;cobweb-canvas&quot;);
    let cobweb_ctx = cobweb_canvas.getContext(&quot;2d&quot;);
    let cobweb_chart = new Chart(cobweb_ctx, {
      type: 'line',
      animation: false,
      data: {
        datasets: [],
      },
      options: {
        annotation: {
          drawTime: 'afterDatasetsDraw',
          annotations: []
        }
      }
    });

    // Parameter r
    let r_slider = document.getElementById(&quot;r-slider&quot;);
    let r = 3.3;

    // Parameters for the plot
    let x_max = 1;
    let x_size = 100;

    // Parameters for cobwebbing
    let do_cobweb = true;
    let starting_point = 0.4;
    let num_cobwebbing_steps = 50;
    let interval_slider = document.getElementById(&quot;interval-slider&quot;)
    let cobweb_interval_time = 200;

    // Setting up x-axis
    // equivalent to: x = linspace(0, x_max, x_size);
    let x = [];
    let x_label = [];
    for (let i = 0; i &lt; x_size; i++) {
      x.push(i*x_max/x_size);
    }

    // Setting up x-labels
    for (let i = 0; i &lt; x_size; i++) {
      x_label.push(i*x_max/x_size);
    }
    cobweb_chart.data.labels = x_label;

    // Plotting y=x
    let y_eq_x = {
      label: 'y = x',
      fill: false,
      pointRadius: 0,
      borderColor: &quot;green&quot;,
      data: x
    };
    cobweb_chart.data.datasets.push(y_eq_x);

    // Plotting the graph for cobwebbing
    let model_data = [];
    for (let i = 0; i &lt; x_size; i++) {
      let par = x[i];
      par = r*par*(1-par);
      model_data.push(par);
    }

    let model = {
      label: 'Discrete Logistic Model',
      fill: false,
      pointRadius: 0,
      borderColor: &quot;blue&quot;,
      data: model_data
    };
    cobweb_chart.data.datasets.push(model);

    cobweb_chart.update();

    // Cobwebbing
    if (do_cobweb) {
      let cobweb_handle;
      let cobweb = [];
      cobweb.push(0);
      cobweb.push(starting_point);
      var step = 0;
      cobweb_chart.update();

      r_slider.oninput = function() {
        clearTimeout(cobweb_handle);
        r = this.value/1000;
        cobweb_chart.data.datasets[1].data = [];
        for (let i = 0; i &lt; x_size; i++) {
          let par = x[i];
          par = r*par*(1-par);
          cobweb_chart.data.datasets[1].data.push(par);
        }
        cobweb_chart.update();
        cobweb = [];
        cobweb.push(0);
        cobweb.push(starting_point);
        step = 0;
        cobweb_chart.options.annotation.annotations = [];
        cobweb_chart.update();
        cobweb_handle = setTimeout(perform_cobweb, cobweb_interval_time*3);
      };

      interval_slider.oninput = function() {
        clearTimeout(cobweb_handle);
        interval_slider = this.value;
        cobweb_handle = setTimeout(perform_cobweb, cobweb_interval_time*3);
      };

      let perform_cobweb = function() {
        step++;
        let par = cobweb[step];
        par = r * par * (1 - par);
        cobweb.push(par);

        setTimeout(draw_vert_cobweb, cobweb_interval_time);
        setTimeout(draw_horiz_cobweb, cobweb_interval_time*2);

        if (step &lt; num_cobwebbing_steps) {
          cobweb_handle = setTimeout(perform_cobweb, cobweb_interval_time*3);
        }
      };

      let draw_vert_cobweb = function() {
        cobweb_chart.options.annotation.annotations.push({
          type: 'box',
          xScaleID: 'x-axis-0',
          yScaleID: 'y-axis-0',
          borderColor: 'pink',
          borderWidth: 3.2,
          xMin: x_label[Math.floor((cobweb[step - 2] || 0) * x_size / x_max)],
          xMax: x_label[Math.floor((cobweb[step - 2] || 0) * x_size / x_max)],
          yMin: cobweb[step - 2] || 0,
          yMax: cobweb[step - 1] || 0
        });

        cobweb_chart.options.annotation.annotations.push({
          type: 'box',
          xScaleID: 'x-axis-0',
          yScaleID: 'y-axis-0',
          borderColor: 'red',
          borderWidth: 3,
          xMin: x_label[Math.floor(cobweb[step - 1] * x_size / x_max)],
          xMax: x_label[Math.floor(cobweb[step - 1] * x_size / x_max)],
          yMin: cobweb[step - 1] || 0,
          yMax: cobweb[step]
        });
        cobweb_chart.update();
      };

      let draw_horiz_cobweb = function() {
        cobweb_chart.options.annotation.annotations.push({
          type: 'box',
          xScaleID: 'x-axis-0',
          yScaleID: 'y-axis-0',
          borderColor: 'pink',
          borderWidth: 3.2,
          xMin: x_label[Math.floor((cobweb[step - 2] || 0) * x_size / x_max)],
          xMax: x_label[Math.floor(cobweb[step - 1] * x_size / x_max)],
          yMin: cobweb[step - 1] || 0,
          yMax: cobweb[step - 1] || 0
        });
        cobweb_chart.options.annotation.annotations.push({
          type: 'box',
          xScaleID: 'x-axis-0',
          yScaleID: 'y-axis-0',
          borderColor: 'red',
          borderWidth: 3,
          xMin: x_label[Math.floor(cobweb[step - 1] * x_size / x_max)],
          xMax: x_label[Math.floor(cobweb[step] * x_size / x_max)],
          yMin: cobweb[step],
          yMax: cobweb[step]
        });
        cobweb_chart.update();
      };

      cobweb_handle = setTimeout(perform_cobweb, cobweb_interval_time*3);
    }

&lt;/script&gt;
&lt;style&gt;
  .slidecontainer {
    width: 100%; /* Width of the outside container */
  }

  /* The slider itself */
  .slider {
    -webkit-appearance: none;  /* Override default CSS styles */
    appearance: none;
    width: 100%; /* Full-width */
    height: 25px; /* Specified height */
    background: #d3d3d3; /* Grey background */
    outline: none; /* Remove outline */
    opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
    -webkit-transition: .2s; /* 0.2 seconds transition on hover */
    transition: opacity .2s;
  }

  /* Mouse-over effects */
  .slider:hover {
    opacity: 1; /* Fully shown on mouse-over */
  }

  /* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
  .slider::-webkit-slider-thumb {
    -webkit-appearance: none; /* Override default look */
    appearance: none;
    width: 25px; /* Set a specific slider handle width */
    height: 25px; /* Slider handle height */
    background: black; /* Green background */
    cursor: pointer; /* Cursor on hover */
  }

  .slider::-moz-range-thumb {
    width: 25px; /* Set a specific slider handle width */
    height: 25px; /* Slider handle height */
    background: black; /* Green background */
    cursor: pointer; /* Cursor on hover */
  }
&lt;/style&gt;</content>

      
      
      
      
      

      <author>
          <name>Hailey Ahn</name>
        
        
      </author>

      

      
        <category term="projects" />
      

      
        <summary type="html">Cobwebbing Analysis for Discrete Logistic Model</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Competitive Programming</title>
      <link href="http://localhost:4000/competitive-programming" rel="alternate" type="text/html" title="Competitive Programming" />
      <published>2020-04-22T17:00:00+09:00</published>
      <updated>2020-04-22T17:00:00+09:00</updated>
      <id>http://localhost:4000/competitive-programming</id>
      <content type="html" xml:base="http://localhost:4000/competitive-programming">&lt;p style=&quot;display:none&quot;&gt;Coding contests and practice codes in C++&lt;/p&gt;


&lt;h1&gt;Competitive Programming&lt;/h1&gt;
&lt;br&gt;
&lt;br&gt;

&lt;blockquote&gt;Competitive programming is a mind sport usually held over the Internet or a local network, involving participants trying to program according to provided specifications. Contestants are referred to as sport programmers.
&lt;br&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Competitive_programming&quot; style=&quot;float:right&quot;&gt;-Wikipedia&lt;/a&gt;
&lt;/blockquote&gt;

&lt;hr&gt;
&lt;h2&gt;C++ Codes&lt;/h2&gt;
&lt;br&gt;
&lt;h3&gt;&lt;a href=&quot;cpp-2020-may&quot;&gt;May 2020 Code Submissions&lt;/a&gt;&lt;/h3&gt;&lt;br&gt;
&lt;h3&gt;&lt;a href=&quot;cpp-2020-april&quot;&gt;April 2020 Code Submissions&lt;/a&gt;&lt;/h3&gt;&lt;br&gt;
&lt;h3&gt;&lt;a href=&quot;cpp-2020-march&quot;&gt;March 2020 Code Submissions&lt;/a&gt;&lt;/h3&gt;&lt;br&gt;
&lt;h3&gt;&lt;a href=&quot;cpp-2020-february&quot;&gt;February 2020 Code Submissions&lt;/a&gt;&lt;/h3&gt;&lt;br&gt;
&lt;h3&gt;&lt;a href=&quot;cpp-2020-january&quot;&gt;January 2020 Code Submissions&lt;/a&gt;&lt;/h3&gt;&lt;br&gt;

&lt;br&gt;
&lt;hr&gt;


&lt;h2&gt;Codeforces&lt;/h2&gt;
&lt;br&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/profile/HaileyA&quot;&gt;Codeforces Profile Page Link&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://codeforces.com/contests/with/HaileyA&quot;&gt;Recent Codeforces Online Contests Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;</content>

      
      
      
      
      

      <author>
          <name>Hailey Ahn</name>
        
        
      </author>

      

      
        <category term="projects" />
      

      
        <summary type="html">Coding contests and practice codes in C++</summary>
      

      
      
    </entry>
  
</feed>
